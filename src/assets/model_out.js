export let models ={
    "payout_sum_late": {
        "name": "payout_sum_late",
        "query": "with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__sum_late as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_late_first) and dekad <= var(sum_late_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ),source as ( select * from __dbt__cte__sum_late ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output"
    },
    "chirps": {
        "name": "chirps",
        "query": "with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output"
    },
    "evi": {
        "name": "evi",
        "query": "with unpivot_result as ( select * from evi_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output"
    },
    "crop_cal_precast": {
        "name": "crop_cal_precast",
        "query": "SELECT gid, crop, activity, GREATEST((start_time - DATE '2020-01-01')/10, 1) as start_time, GREATEST((end_time - DATE '2020-01-01')/10, 1) as end_time FROM crop_cal_raw WHERE gid='var(region)'"
    },
    "vegetation_evi": {
        "name": "vegetation_evi",
        "query": "with __dbt__cte__evi as ( with unpivot_result as ( select * from evi_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ),source as ( select * from __dbt__cte__evi ), intervel as ( select * from source where dekad >= var(vegetation_first) and dekad <= var(vegetation_last) ), rain_window as ( select year, sum(value) *var(scalar_vegetation) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output"
    },
    "badyear": {
        "name": "badyear",
        "query": "SELECT * FROM badyear_raw WHERE gid='var(region)' AND is_bad_year = 1"
    },
    "climatology": {
        "name": "climatology",
        "query": "with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ),source as ( select * from __dbt__cte__chirps ), climatology as ( select dekad, avg(value_cap) as average_value from source group by dekad order by dekad ) select * from climatology"
    },
    "payout_combined": {
        "name": "payout_combined",
        "query": "with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__sum_early as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_early_first) and dekad <= var(sum_early_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_sum_early as ( with source as ( select * from __dbt__cte__sum_early ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__sum_late as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_late_first) and dekad <= var(sum_late_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_sum_late as ( with source as ( select * from __dbt__cte__sum_late ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__evi as ( with unpivot_result as ( select * from evi_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__vegetation_evi as ( with source as ( select * from __dbt__cte__evi ), intervel as ( select * from source where dekad >= var(vegetation_first) and dekad <= var(vegetation_last) ), rain_window as ( select year, sum(value) *var(scalar_vegetation) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_vegetation_evi as ( with source as ( select * from __dbt__cte__vegetation_evi ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ),source as ( select a.year as year, var(sum_early_weight)*a.payout + var(vegetation_weight)*GREATEST(b.payout,c.payout) as combined_payout, a.payout as sum_early, b.payout as sum_late, c.payout as vegetation from __dbt__cte__payout_sum_early a join __dbt__cte__payout_sum_late b on a.year = b.year left join __dbt__cte__payout_vegetation_evi c on a.year = c.year ) select * from source"
    },
    "crop_cal": {
        "name": "crop_cal",
        "query": "with __dbt__cte__crop_cal_precast as ( SELECT gid, crop, activity, GREATEST((start_time - DATE '2020-01-01')/10, 1) as start_time, GREATEST((end_time - DATE '2020-01-01')/10, 1) as end_time FROM crop_cal_raw WHERE gid='var(region)' )SELECT gid, crop, activity, start_time::INTEGER AS start_time, end_time::INTEGER AS end_time FROM __dbt__cte__crop_cal_precast"
    },
    "matching": {
        "name": "matching",
        "query": "with __dbt__cte__badyear as ( SELECT * FROM badyear_raw WHERE gid='var(region)' AND is_bad_year = 1 ), __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__sum_early as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_early_first) and dekad <= var(sum_early_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_sum_early as ( with source as ( select * from __dbt__cte__sum_early ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__sum_late as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_late_first) and dekad <= var(sum_late_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_sum_late as ( with source as ( select * from __dbt__cte__sum_late ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__evi as ( with unpivot_result as ( select * from evi_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__vegetation_evi as ( with source as ( select * from __dbt__cte__evi ), intervel as ( select * from source where dekad >= var(vegetation_first) and dekad <= var(vegetation_last) ), rain_window as ( select year, sum(value) *var(scalar_vegetation) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_vegetation_evi as ( with source as ( select * from __dbt__cte__vegetation_evi ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__payout_combined as ( with source as ( select a.year as year, var(sum_early_weight)*a.payout + var(vegetation_weight)*GREATEST(b.payout,c.payout) as combined_payout, a.payout as sum_early, b.payout as sum_late, c.payout as vegetation from __dbt__cte__payout_sum_early a join __dbt__cte__payout_sum_late b on a.year = b.year left join __dbt__cte__payout_vegetation_evi c on a.year = c.year ) select * from source )SELECT a.gid, b.year, a.is_bad_year, b.combined_payout, b.sum_early, b.sum_late, b.vegetation FROM __dbt__cte__badyear a RIGHT JOIN __dbt__cte__payout_combined b ON a.year = b.year"
    },
    "check": {
        "name": "check",
        "query": "with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__sum_early as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_early_first) and dekad <= var(sum_early_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_sum_early as ( with source as ( select * from __dbt__cte__sum_early ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__sum_late as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_late_first) and dekad <= var(sum_late_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_sum_late as ( with source as ( select * from __dbt__cte__sum_late ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__evi as ( with unpivot_result as ( select * from evi_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__vegetation_evi as ( with source as ( select * from __dbt__cte__evi ), intervel as ( select * from source where dekad >= var(vegetation_first) and dekad <= var(vegetation_last) ), rain_window as ( select year, sum(value) *var(scalar_vegetation) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_vegetation_evi as ( with source as ( select * from __dbt__cte__vegetation_evi ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__payout_combined as ( with source as ( select a.year as year, var(sum_early_weight)*a.payout + var(vegetation_weight)*GREATEST(b.payout,c.payout) as combined_payout, a.payout as sum_early, b.payout as sum_late, c.payout as vegetation from __dbt__cte__payout_sum_early a join __dbt__cte__payout_sum_late b on a.year = b.year left join __dbt__cte__payout_vegetation_evi c on a.year = c.year ) select * from source )select sum(a.combined_payout) from __dbt__cte__payout_combined a"
    },
    "payout_vegetation_evi": {
        "name": "payout_vegetation_evi",
        "query": "with __dbt__cte__evi as ( with unpivot_result as ( select * from evi_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__vegetation_evi as ( with source as ( select * from __dbt__cte__evi ), intervel as ( select * from source where dekad >= var(vegetation_first) and dekad <= var(vegetation_last) ), rain_window as ( select year, sum(value) *var(scalar_vegetation) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ),source as ( select * from __dbt__cte__vegetation_evi ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output"
    },
    "sum_early": {
        "name": "sum_early",
        "query": "with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ),source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_early_first) and dekad <= var(sum_early_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output"
    },
    "vegetation_chirps": {
        "name": "vegetation_chirps",
        "query": "with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ),source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(vegetation_first) and dekad <= var(vegetation_last) ), rain_window as ( select year, sum(value) *var(scalar_vegetation) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output"
    },
    "payout_sum_early": {
        "name": "payout_sum_early",
        "query": "with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__sum_early as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_early_first) and dekad <= var(sum_early_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ),source as ( select * from __dbt__cte__sum_early ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output"
    },
    "sum_late": {
        "name": "sum_late",
        "query": "with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ),source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_late_first) and dekad <= var(sum_late_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output"
    }
}